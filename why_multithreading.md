# JVM과 스레드

## 컨텍스트 스위칭 (Context Switching)

- 스레드의 **실행 상태**는 CPU 레지스터 값으로 표현됨  
- 스레드 전환 시:
  - 이전 스레드의 상태를 **백업**
  - 새로운 스레드의 상태를 **복원**
- 이러한 정보는 `TCB(Thread Control Block)`에 저장됨

---

## 객체 메모리 레이아웃과 `hashCode()`

Java의 모든 객체는 다음과 같은 메모리 구조를 가짐:

### 객체 헤더 (Object Header)

- **Mark Word**
  - GC 생존 횟수 (Age)
  - 락 정보 (Lock Flag)
  - `hashCode()` 호출 시 계산되어 저장
- **Class Pointer**
  - 객체가 속한 클래스 정보를 가리킴

---

## JVM의 객체 수준 Lock

- Java에서는 모든 함수와 자료가 **Class에 소속**
- **정적 멤버**는 인스턴스 없이 존재하므로, 동기화가 필요할 경우 **Monitor Lock**을 활용하여 임계 영역을 제어

---

## JVM과 컴퓨터 구조

- Java는 하드웨어(H/W)나 운영체제(OS)에 직접 접근하지 않고  
  **JVM이라는 가상 머신 위에서 실행**
- JVM은 **운영체제와 하드웨어 추상화 계층**의 역할을 수행

---

## Java Memory Model (JMM)

### 핵심 목표

> 변수에 대한 **읽기(Read)**, **쓰기(Write)** 규칙을 정의

### 구성 요소

- **메인 메모리**
  - JVM이 모든 변수를 저장하는 공간 (Heap, Static 등)
- **작업 메모리**
  - 각 스레드가 사용하는 **변수의 사본**
  - 스레드 내부 연산은 작업 메모리에서만 수행됨

> ※ 지역 변수, 매개 변수는 Stack에 저장되어 JMM 규칙과 무관

---

## 연산 흐름 (JMM 내 메모리 접근)

| 단계   | 설명 |
|--------|------|
| Read   | 메인 메모리에서 변수 값을 읽음 |
| Load   | 읽은 값을 작업 메모리에 저장 |
| Store  | 작업 메모리 값을 메인 메모리로 전송 |
| Write  | 전송된 값을 메인 메모리에 반영 |

---

## JVM 메인 메모리와 작업 메모리

- Java 메모리 모델의 핵심 목표는 변수 접근 규칙을 정의하는 것
- 변수는 메인 메모리에 저장되며, 스레드는 자신의 작업 메모리에서 변수의 복사본을 가지고 연산을 수행
- 스레드 간에는 작업 메모리를 공유하지 않음
- 스레드는 메인 메모리에 직접 접근할 수 없음

---

## 작업 메모리 동기화 이슈

- 작업 메모리의 변경 내용은 메인 메모리에 **즉시 반영되지 않음**
- 이는 성능 향상을 위한 일괄 처리 목적
- 일반 변수의 동기화는 다음의 경우 발생함:
  - `synchronized`, `volatile` 키워드 사용 시
  - `Thread.start()`, `Thread.join()` 호출 시
  - `Lock`, `Atomic` 클래스 사용 시
  - 클래스 로딩 중 정적 변수 초기화 시
  - 기타 JVM 최적화/동기화 기준 충족 시

---

## 작업 메모리 동기화 - 스레드 시작/종료

- **스레드 시작 시**:  
  부모 스레드의 작업 메모리에 있는 변수 값을 메인 메모리에 동기화  
  → 기존 스레드에서 확인 가능

- **스레드 종료 후**:  
  작업 메모리 값이 메인 메모리에 동기화됨

- **새 스레드**는 동기화된 메인 메모리에서 변수 값을 로딩

---

## `volatile` 키워드의 의미

- **멀티스레드 환경에서 변수의 가시성(Visibility)** 보장
  - 변수에 접근할 때마다 **메인 메모리와 동기화**
- **명령어 재정렬(Instruction Reordering) 방지**
  - 실행 순서가 코드 순서와 다르게 최적화되지 않음

```java
volatile boolean flag = true;
```

## 경쟁 조건 (Race Condition)

- 여러 스레드가 **동시에 같은 자원에 접근**하면서 발생하는 문제  
- 스레드 간의 실행 순서에 따라 결과가 달라지는 **논리적 오류**
- 컴파일 타임에서는 감지되지 않으며, **런타임에서 비정상적인 동작**이 발생할 수 있음
- Java도 예외는 아니며, **C/C++의 포인터 참조 문제와 유사**한 형태로 나타날 수 있음

> 해결 방법: `synchronized`, `Lock`, `Atomic` 클래스 등을 이용한 동기화 처리

---

## 가상 스레드 (Virtual Thread)

- 커널 스레드와 분리된 **경량 스레드 개념**
- 실제로는 하나의 **커널 스레드가 여러 가상 스레드**를 번갈아 실행
- 각각이 **독립된 스레드처럼 보이지만**, 내부적으로는 커널 스레드를 공유함
- 이를 통해 다음과 같은 장점이 있음:
  - **스레드 생성 비용 감소**
  - **컨텍스트 스위칭 오버헤드 최소화**
  - 수십만 개의 동시 실행 흐름을 **효율적으로 처리**

> ✅ Java 21부터 정식 도입 (Project Loom)
